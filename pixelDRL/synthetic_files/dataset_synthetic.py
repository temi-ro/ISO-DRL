# File entirely generated by Google Gemini 3 (For more info, see report Section 7.1)

# This is a synthetic dataset class that generates simple images with either a square or a circle
# in the center. The images are 240x240 pixels, and the shapes are randomly sized and positioned.
# The dataset returns a tuple of (image, rl_target, binary_mask) where:
# - image: The input image with the shape and some noise.
# - rl_target: The same as the binary mask (for simplicity in this synthetic example).
# - binary_mask: A binary mask indicating the location of the shape (1 for shape, 0 for background).

import torch
from torch.utils.data import Dataset
import numpy as np
import random

class SyntheticShapesDataset(Dataset):
    def __init__(self, size=1000, img_size=240):
        self.size = size
        self.img_size = img_size

    def __len__(self):
        return self.size

    def __getitem__(self, idx):
        # 1. Create Blank Image (Black Background)
        img = np.zeros((self.img_size, self.img_size), dtype=np.float32)
        mask = np.zeros((self.img_size, self.img_size), dtype=np.float32)

        # 2. Randomly choose: Square or Circle
        shape_type = random.choice(['square', 'circle'])
        
        # Random center and size
        cx = random.randint(20, self.img_size - 20)
        cy = random.randint(20, self.img_size - 20)
        radius = random.randint(10, 30)

        if shape_type == 'square':
            # Draw Square
            x1, x2 = max(0, cx - radius), min(self.img_size, cx + radius)
            y1, y2 = max(0, cy - radius), min(self.img_size, cy + radius)
            img[y1:y2, x1:x2] = 1.0
            mask[y1:y2, x1:x2] = 1.0
            
        else: # Circle
            # Draw Circle
            y, x = np.ogrid[:self.img_size, :self.img_size]
            dist_from_center = np.sqrt((x - cx)**2 + (y - cy)**2)
            circle_mask = dist_from_center <= radius
            img[circle_mask] = 1.0
            mask[circle_mask] = 1.0

        # 3. Add Noise (Optional - makes it slightly harder/realistic)
        noise = np.random.normal(0, 0.1, img.shape).astype(np.float32)
        img = img + noise
        img = np.clip(img, 0, 1)

        # 4. Convert to Tensor [C, H, W]
        image_tensor = torch.from_numpy(img).unsqueeze(0)
        mask_tensor = torch.from_numpy(mask).unsqueeze(0)

        # Return format matching your BraTS dataset: (image, rl_target, binary_mask)
        return image_tensor, mask_tensor, mask_tensor